并发遇到的问题



## 资源占用问题

多个进程使用同一个资源，会出现问题

### 使用锁

sync 包中有 互斥锁 Mutex，即当一个进程使用资源时，另一个资源堵塞

```
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    ch := make(chan struct{}, 2)

    var l sync.Mutex
    go func() {
        l.Lock()
        defer l.Unlock()
        fmt.Println("goroutine1: 我会锁定大概 2s")
        time.Sleep(time.Second * 2)
        fmt.Println("goroutine1: 我解锁了，你们去抢吧")
        ch <- struct{}{}
    }()

    go func() {
        fmt.Println("groutine2: 等待解锁")
        l.Lock()
        defer l.Unlock()
        fmt.Println("goroutine2: 哈哈，我锁定了")
        ch <- struct{}{}
    }()

    // 等待 goroutine 执行结束
    for i := 0; i < 2; i++ {
        <-ch
    }
}
```

​         如常用的对 map 读写时，操作 map 时就可以加锁

```
lock.Lock()   // 在进行存储操作之前，先加锁
myRes[n] = res
lock.Unlock()  // 当存储完毕后，进行解锁
```

sync 包中还有读写锁，对读写加锁

### 使用 channel



## 主线程过快导致其他进程提前结束

### 使用 waitGroup

waitGroup 是 sync 包中的一个东西，使主进程等待，其他进程开始时进程数加一，进程结束时进程减一，最后进程数为 0 是主进程恢复，这样就是每个进程都能执行完

```
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var wg sync.WaitGroup

    for i := 0; i < 5; i++ {
        // 计数加 1
		// 注意，wg.Add() 方法一定要在 goroutine 开始前执行
		wg.Add(1)
        go func(i int) {
            // 计数减 1
            defer wg.Done()
            time.Sleep(time.Second * time.Duration(i))
            fmt.Printf("goroutine%d 结束\n", i)
        }(i)
    }

    // 等待执行结束
    wg.Wait()
    fmt.Println("所有 goroutine 执行结束")
}
```

### 使用 channel

