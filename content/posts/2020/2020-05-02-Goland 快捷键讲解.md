---
title: Goland 快捷键讲解
author: "edte"
categories: ["Goland"]
date: 2020-05-02
---







快捷键过多是没有意义的。快捷键和功能间没有练习，需要建立肌肉记忆。

需要两个工具：
提示快捷键的工具。
直接搜索功能的工具。





## 移动光标的方法

上 下 左 右 行首  行尾  up  down

跳转到定义
ctrl+B

屏幕跳转到任意字符
插件： acejump-lite
alt+m 后输入字符



ctrl+shfit  返回刚打开的 tab



Ctrl+e  查看最近编辑的文件

Ctrl+shift+e  查看最近编辑的地方



shift+enter  新建下一行并到下一行
ctrl+enter   新建下一行
ctrl+alt+enter   新建上一行并到上一行

Ctrl+Shift+A  查找 action

Ctrl+N  fing type

Ctrl+Shift+N  查找 file
Ctrl+Alt+Shift+N  查找 func

Ctrl+3     移动到下一个 error
Ctrl+2     移动到上一个 error



* 其他




保存的同时格式化代码和优化导包（一个快捷键，自己设置）

Ctrl+Alt+L 格式化代码
Ctrl+Alt+O 优化导入的类和包
Ctrl+S     save





Ctrl+/  行注释

Ctrl+shift+/  快注释



Alt+enter 选择 context action 来修复
常用于

* import 后用于 sync 包，代替 go get
* 使用 struct 时 fill all fileds
* return 时缺少值时 add missing return values
* 调用函数时，有不用的返回值，将返回值 rename _
* 调用函数时，返回值个数不够，insert bank indentifilers to left side



Alt+1   打开侧边栏

Shift+F6   rename  所有的文件，类名，函数名，属性名都可以重命名，使用 Shift+F6 重命名，所有使用过这个名称的地方都会跟着改变



Ctrl+1    显示 error
Ctrl+p    显示参数  parameter info

Ctrl+Q  show documentation, 用来显示返回值比较方便



Ctrl+R     run
Ctrl+b    到变量声明处

Ctrl+w   extend w



Ctrl+shift+y   translate

Ctrl+shift+o  show translation log





Ctrl+k    git add and commit
Ctrk+shift+k    git push

Ctrl+shfit+enter  coplete current statement

Ctrl+shift+space 智能提示





Ctrl+shift+f   find in path
Ctrl+shift+r   replace in path





column selection mode，列选择模式，打开后按住 shift 再移动上下键即可

或者 Ctrl+w 选中单词后 Alt+j 选中相同的变量









Ctrl+d  重复当前行或选中文本

Ctrl+x 剪切当前行

Ctrl+c 双击复制当前行

Ctrl+y 删除当前行







Ctrl+shfit+t   生成测试文件



action_list:

* find usage 查找方法被调用的地方



## 代码生成

### 最特殊的键 alt+enter  

此 action name 是 show context actions

这个键的作用可以在 Settings>Editor>Intensions>go 中查看

最常用的几个就是 `struct 相关`和`调用函数`以及`add comment`了



#### struct 相关

* File all fields

使用 struct 时，补全 其所有 fileds，只限于第一层，若 fileds 有 struct ，则不 fill 子 struct, 在 使用的 struct 里使用即可

Before

```
type Address struct { Street string; City string }
type Person struct { Name string; Location Address }

_ = Person{}
```

After

```
type Address struct { Street string; City string }
type Person struct { Name string; Location Address }

_ = Persona{
	Name:     "",
	Location: Address{},
}
```

* File all fileds recursively

使用 struct 时，补全 其所有 fileds，只限于第一层，若 fileds 有 struct ，则递归的 fill 所有 struct, 在 使用的 struct 里使用即可

Before

```
type Address struct { Street string; City string }
type Person struct { Name string; Location Address }

_ = Person{}
```

After

```
type Address struct { Street string; City string }
type Person struct { Name string; Location Address }

_ = Persona{
	Name: "",
	Location: Address{
		Street: "",
		City:   "",
	},
}
```

* file fileds

使用 struct， 选择一个 filed 补全， 在使用的 struct 里使用即可

Before

```
type Address struct { Street string; City string }
type Person struct { Name string; Location Address }

_ = Person{}
```

After

```
type Address struct { Street string; City string }
type Person struct { Name string; Location Address }

_ = Persona{
	Name:     "",
}
```

* Generate constructor

给 struct 生成 new 方法，在 struct 的声明处使用

Before

```
type Person struct {
	name string
	age int
}
```

After

```
type Person struct {
	name string
	age int
}

func NewPerson(name string, age int) *Person {
	return &Person{name: name, age: age}
} 
```

* Generate getter

给 struct filed 生成 getter 方法，在 struct 声明处，对着要生成的特定 file 即可

Before

```
type Person struct {
	name string
}
```

After

```
type Person struct {
	name string
}

func (p *Person) Name() string {
	return p.name
}
```

* Generate setter

给 struct filed 生成 setter 方法，在 struct 声明处，对着要生成的特定 file 即可 

Before

```
type Person struct {
	name string
}
```

After

```
type Person struct {
	name string
}

func (p *Person) SetName(name string) {
	p.name = name
}
```

* Generate getter and setter

给 struct filed 生成 getter 和 setter 方法，在 struct 声明处，对着要生成的特定 file 即可

Before

```
type Person struct {
	name string
}
```

After

```
type Person struct {
	name string
}

func (p *Person) Name() string {
	return p.name
}

func (p *Person) SetName(name string) {
	p.name = name
}
```

* Implement interface

给结构体实现某接口，接口可以是自定义的，也可以是已有的。也就是给结构体生成接口含有的所有方法。这个功能有快捷键 Ctrl+i, 对着结构体的声明处使用即可

Before

```
package main

type A struct {}

type B interface {
	a1() int
	a2() int
	a3() int
}
```

After

```
package main

type A struct {}

func (*A) a1() int {
	panic("implement me")
}

func (*A) a2() int {
	panic("implement me")
}

func (*A) a3() int {
	panic("implement me")
}

type B interface {
	a1() int
	a2() int
	a3() int
}
```

* Move field assignment to struct initialization

使用了一个 struct, 然后又写了一个赋值语句，这个命令是把两个语句合成一个语句，在 初始化语句里使用即可

Before

```
s := S{}
s.foo = `bar`
```

After

```
s := S{foo: `bar`}
```

* Remove keys from struct literal

使用 struct 时，把 filed name 去掉，在使用 struct 时使用

Before

```
var _ = struct{int; string; slice []int}{string : "a", int : 2}
```

After

```
var _ = struct{int; string; slice []int}{2, "a", nil}
```



#### 调用函数

* Introduce to local variable

调用函数时，迅速生成赋值返回值变量，对着调用的函数名使用

Before

```
func Add(a int, b int) int {
	return a + b
}
func main() {
	Add(1, 2)
}
```

After

```
func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	add, err := Add(1, 2)
}
```

* Rename _

调用函数后，把没有使用的赋值变量变为 _ , 对着没有使用的变量使用即可

Before

```
func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	a, err := Add(1, 2)
}
```

After

```
func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	_, err := Add(1, 2)
}
```

* Insert bank identifies to left side of assginment statement

调用函数时，若有多个返回值，而赋值的变量没有返回值多，那么对着变量使用后，会自动补全返回值个数

Before

```
func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	a := Add(1, 2)
}
```

After

```
func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	a, _ := Add(1, 2)
}
```

* Replace with ":"

调用函数时，若赋值的变量没有声明，那么对其使用就会直接声明后赋值

Before

```
func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	a = Add(1, 2)
}
```

AAfter

```
func Add(a int, b int) (int, error) {
	return a + b, nil
}
func main() {
	a := Add(1, 2)
}
```

* Add missing return values

函数 return 返回值时，若个数不够，那么在 return 使用会自动增加返回值

Before

```
func Add(a int, b int) (int, error) {
	return a + b
}
```

After

```
func Add(a int, b int) (int, error) {
	return a + b, nil
}
```

* Remove 2nd result parameter from function 

函数 return 返回值时，若个数不够, 或者调用函数时，赋值的变量比返回值少，使用后会把返回值减少到对应个数

Before

```
func Add(a int, b int) (int, error) {
	return a + b, nil
}

func main() {
	a := Add(1, 2)
}
```

After

```
func Add(a int, b int) int {
	return a + b
}

func main() {
	a := Add(1, 2)
}
```

或者

Before

```
func Add(a int, b int) (int, error) {
	return a + b
}
```

After

```
func Add(a int, b int) int {
	return a + b
}
```

#### 声明变量

* Add parens to declaration

给单个变量声明时添加括号，在变量声明处使用

Before

```
var a string
```

After

```
var (
	a string
)
```

> 这里说一下 import 时的情况，在 goland 中，只 import 了一个package，要加括号的话在 import 后直接打 ( 即可，goland 会自动把其放入括号中

* Remove parens from declaration

与 Add parens to delartion 相反，去除括号

Before

```
var (
	a string
)
```

After

```
var a string
```

* Merge all declaration

给连续三个以上的变量声明划分为一组，空格隔开的不算，对着变量使用即可

Before

```
var a string

var b int
var c float32
var d bool

var e int
```

After

```
var a string

var (
	b int
	c float32
	d bool
)

var e int
```

* split all declaration

与  Merge all declaration 相反，会把括号里的变量分开声明

Before

```
var (
	a string
	b int
	c int
)
```

After

```
var a string
var b int
var c int
```

* merge declaration up

把这个变量和上一个声明的变量放在一个括号中，空格不影响

Before

```
var a string
var b int
```

After

```
var (
	a string
	b int
)
```

* merge declaration up via comma

把这个变量和上一个声明的变量放在一行，空格不影响

Before

```
var a int
var b int
```

After

```
var a, b int
```

* split declaration by comma

 于 merge declaration up via comma 相反，把一行声明的变量变为多行声明

Before

```
var a, b int
```

After

```
var a int
var b int
```



*  convert to short var declaration

把 var 变量的声明格式变为更短的  :=  格式，在 var 变量声明处使用

Before

```
var x = 1
```

After

```
x := 1
```

* convert to var declaration

与 convert to short var declaration 相反，把 := 声明的变量变为 var 声明的格式，在 := 变量声明处使用

Before

```
x := 1
```

After

```
var x = 1
```



#### 函数其他
* Add comment

在声明函数的地方，对着函数名可以生成此函数的注释

Before

```
package foo

func Foo() {

}
```

After

```
package foo

// Foo 
func Foo() {

}
```



* add format string argument

在支持格式化的函数的参数里， 即 ("") 的引号中使用。选择一个变量后，会自动生成相应的格式化输出。

如 int 类型 a, 输入 a 后会自动生成 %d, 而无需记忆对应的意义。

Before

```
func log(count int) {
	fmt.Printf(`count is: `)
}
```

After

```
func log(count int) {
	fmt.Printf(`count is: %d`, count)
}
```

* Expand signature types

在参数和返回值时，转换类型的写法, 在参数或返回值括号内使用即可

Before

```
func foo(s1, s2 string) (i1, i2 int) {
	return 0, 1
}
```

After

```
func foo(s1 string, s2 string) (i1 int, i2 int) {
	return 0, 1
}
```

* Reuse signature types

与上面的 Expand signature types 相反

Before 

```
func bar(s1 string, s2 string) (i1 int, i2 int) {
	return 0, 1
}
```

After

```
func bar(s1, s2 string) (i1, i2 int) {
	return 0, 1
}
```



*  Export 

把私有 func, type, filed 变为公有的，在 func或 type 或 sturct 里的 filed 里使用即可

Before

```
func private() {}
```

After

```
func Private() {}
```

*  Invert if

把 if- else 语句反过来，在 操作符 处使用即可

Before 

```
a := 1
if a >= 2 {
	fmt.Println("a >= 2")
} else {
	fmt.Println("a < 2")
}
```

After

```
a := 1
if a < 2 {
	fmt.Println("a < 2")
} else {
	fmt.Println("a >= 2")
}
```





#### 导包

* Add dot import alias

在导的包前或使用的包名中使用，可以直接用包里的函数

 Before

```
package main

import "fmt"

func main() {
    fmt.Println("Hello World!")
}
```

After

```
package main

import . "fmt"

func main() {
    Println("Hello World!")
}
```

* Remove dot import alias

和 Add dot import alias 相反，取消其效果，导的包前或使用的包名中使用

Before

```
package main

import . "fmt"

func main() {
    Println("Hello World!")
}
```

After

```
package main

import "fmt"

func main() {
    fmt.Println("Hello World!")
}
```

* Add import alias

这个同样在导的包前或使用的包名中使用，可以给包设置别名

Before

```
package main

import "fmt"

func main() {
    fmt.Println("Hello World!")
}
```

After

```
package main

import fmtAlias "fmt"

func main() {
    fmtAlias.Println("Hello World!")
}
```



#### 操作表达式的改变

*  flip binary operator
*  negate expression
*  negate expression recurisively
*  negate topmostexpression
*  negate topmostexpression recurisively

这几个都是不常用的（至少我没怎么用到)

### 生成测试代码 Ctrl+Shift+T

此 action name 是 go to  test

这个键一共有 4 个功能

#### Test for functions

这个是最常用的，在函数内使用即可。

这个功能是生成函数测试。

go 中的测试文件需要在原有文件名后加上 _test, 测试函数需要在函数名前加上 Test ,参数也是特殊的。

如果手动生成的话比较麻烦且容易忘记，于是可以使用此快捷键。

如：

Before

```
db.go 中

func Hello {
	fmt.Println("Hello World")
}
```

After

```
生成 db_test.go 文件
其中 
func TestHello(t *testing.T) {
//...
}
```

#### Test for files

生成此 files 内的所有函数的 test

#### Test for package

生成此 package 内的所有函数的 test

#### empty test file

生成空 test file, 里面没有 TestFunc